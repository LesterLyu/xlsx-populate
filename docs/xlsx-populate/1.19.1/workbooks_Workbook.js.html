<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>workbooks/Workbook.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Cell.html">Cell</a><ul class='methods'><li data-type='method'><a href="Cell.html#_evaluateFormula">_evaluateFormula</a></li><li data-type='method'><a href="Cell.html#active">active</a></li><li data-type='method'><a href="Cell.html#active">active</a></li><li data-type='method'><a href="Cell.html#addHorizontalPageBreak">addHorizontalPageBreak</a></li><li data-type='method'><a href="Cell.html#address">address</a></li><li data-type='method'><a href="Cell.html#clear">clear</a></li><li data-type='method'><a href="Cell.html#column">column</a></li><li data-type='method'><a href="Cell.html#columnName">columnName</a></li><li data-type='method'><a href="Cell.html#columnNumber">columnNumber</a></li><li data-type='method'><a href="Cell.html#dataValidation">dataValidation</a></li><li data-type='method'><a href="Cell.html#dataValidation">dataValidation</a></li><li data-type='method'><a href="Cell.html#dependencies">dependencies</a></li><li data-type='method'><a href="Cell.html#find">find</a></li><li data-type='method'><a href="Cell.html#formula">formula</a></li><li data-type='method'><a href="Cell.html#formula">formula</a></li><li data-type='method'><a href="Cell.html#formula">formula</a></li><li data-type='method'><a href="Cell.html#getMasterSharedFormulaCell">getMasterSharedFormulaCell</a></li><li data-type='method'><a href="Cell.html#getStyle">getStyle</a></li><li data-type='method'><a href="Cell.html#getValue">getValue</a></li><li data-type='method'><a href="Cell.html#hyperlink">hyperlink</a></li><li data-type='method'><a href="Cell.html#hyperlink">hyperlink</a></li><li data-type='method'><a href="Cell.html#hyperlink">hyperlink</a></li><li data-type='method'><a href="Cell.html#hyperlink">hyperlink</a></li><li data-type='method'><a href="Cell.html#isMasterMergedCell">isMasterMergedCell</a></li><li data-type='method'><a href="Cell.html#isMasterShardFormula">isMasterShardFormula</a></li><li data-type='method'><a href="Cell.html#isSharedFormula">isSharedFormula</a></li><li data-type='method'><a href="Cell.html#masterMergedCell">masterMergedCell</a></li><li data-type='method'><a href="Cell.html#merged">merged</a></li><li data-type='method'><a href="Cell.html#rangeTo">rangeTo</a></li><li data-type='method'><a href="Cell.html#recalculate">recalculate</a></li><li data-type='method'><a href="Cell.html#relativeCell">relativeCell</a></li><li data-type='method'><a href="Cell.html#row">row</a></li><li data-type='method'><a href="Cell.html#rowNumber">rowNumber</a></li><li data-type='method'><a href="Cell.html#setFormula">setFormula</a></li><li data-type='method'><a href="Cell.html#setStyle">setStyle</a></li><li data-type='method'><a href="Cell.html#setValue">setValue</a></li><li data-type='method'><a href="Cell.html#sharedFormula">sharedFormula</a></li><li data-type='method'><a href="Cell.html#sheet">sheet</a></li><li data-type='method'><a href="Cell.html#style">style</a></li><li data-type='method'><a href="Cell.html#style">style</a></li><li data-type='method'><a href="Cell.html#style">style</a></li><li data-type='method'><a href="Cell.html#style">style</a></li><li data-type='method'><a href="Cell.html#style">style</a></li><li data-type='method'><a href="Cell.html#style">style</a></li><li data-type='method'><a href="Cell.html#tap">tap</a></li><li data-type='method'><a href="Cell.html#thru">thru</a></li><li data-type='method'><a href="Cell.html#value">value</a></li><li data-type='method'><a href="Cell.html#value">value</a></li><li data-type='method'><a href="Cell.html#value">value</a></li><li data-type='method'><a href="Cell.html#workbook">workbook</a></li></ul></li><li><a href="Column.html">Column</a><ul class='methods'><li data-type='method'><a href="Column.html#addPageBreak">addPageBreak</a></li><li data-type='method'><a href="Column.html#address">address</a></li><li data-type='method'><a href="Column.html#cell">cell</a></li><li data-type='method'><a href="Column.html#columnName">columnName</a></li><li data-type='method'><a href="Column.html#columnNumber">columnNumber</a></li><li data-type='method'><a href="Column.html#hidden">hidden</a></li><li data-type='method'><a href="Column.html#hidden">hidden</a></li><li data-type='method'><a href="Column.html#sheet">sheet</a></li><li data-type='method'><a href="Column.html#style">style</a></li><li data-type='method'><a href="Column.html#style">style</a></li><li data-type='method'><a href="Column.html#style">style</a></li><li data-type='method'><a href="Column.html#style">style</a></li><li data-type='method'><a href="Column.html#style">style</a></li><li data-type='method'><a href="Column.html#width">width</a></li><li data-type='method'><a href="Column.html#width">width</a></li><li data-type='method'><a href="Column.html#workbook">workbook</a></li></ul></li><li><a href="DataValidations.html">DataValidations</a><ul class='methods'><li data-type='method'><a href="DataValidations.html#delete">delete</a></li><li data-type='method'><a href="DataValidations.html#get">get</a></li><li data-type='method'><a href="DataValidations.html#getDataValidation">getDataValidation</a></li><li data-type='method'><a href="DataValidations.html#parse">parse</a></li><li data-type='method'><a href="DataValidations.html#parseFormula">parseFormula</a></li><li data-type='method'><a href="DataValidations.html#set">set</a></li><li data-type='method'><a href="DataValidations.html#setDataValidation">setDataValidation</a></li><li data-type='method'><a href="DataValidations.html#toXml">toXml</a></li><li data-type='method'><a href="DataValidations.html#validate">validate</a></li></ul></li><li><a href="FormulaError.html">FormulaError</a><ul class='methods'><li data-type='method'><a href="FormulaError.html#error">error</a></li></ul></li><li><a href="Hyperlinks.html">Hyperlinks</a><ul class='methods'><li data-type='method'><a href="Hyperlinks.html#delete">delete</a></li><li data-type='method'><a href="Hyperlinks.html#get">get</a></li><li data-type='method'><a href="Hyperlinks.html#parse">parse</a></li><li data-type='method'><a href="Hyperlinks.html#set">set</a></li><li data-type='method'><a href="Hyperlinks.html#toXml">toXml</a></li></ul></li><li><a href="MergeCells.html">MergeCells</a><ul class='methods'><li data-type='method'><a href="MergeCells.html#delete">delete</a></li><li data-type='method'><a href="MergeCells.html#get">get</a></li><li data-type='method'><a href="MergeCells.html#parse">parse</a></li><li data-type='method'><a href="MergeCells.html#set">set</a></li><li data-type='method'><a href="MergeCells.html#toXml">toXml</a></li></ul></li><li><a href="PageBreaks.html">PageBreaks</a><ul class='methods'><li data-type='method'><a href="PageBreaks.html#add">add</a></li><li data-type='method'><a href="PageBreaks.html#remove">remove</a></li></ul></li><li><a href="Range.html">Range</a><ul class='methods'><li data-type='method'><a href="Range.html#address">address</a></li><li data-type='method'><a href="Range.html#autoFilter">autoFilter</a></li><li data-type='method'><a href="Range.html#cell">cell</a></li><li data-type='method'><a href="Range.html#cells">cells</a></li><li data-type='method'><a href="Range.html#clear">clear</a></li><li data-type='method'><a href="Range.html#dataValidation">dataValidation</a></li><li data-type='method'><a href="Range.html#dataValidation">dataValidation</a></li><li data-type='method'><a href="Range.html#endCell">endCell</a></li><li data-type='method'><a href="Range.html#forEach">forEach</a></li><li data-type='method'><a href="Range.html#formula">formula</a></li><li data-type='method'><a href="Range.html#formula">formula</a></li><li data-type='method'><a href="Range.html#map">map</a></li><li data-type='method'><a href="Range.html#merged">merged</a></li><li data-type='method'><a href="Range.html#merged">merged</a></li><li data-type='method'><a href="Range.html#reduce">reduce</a></li><li data-type='method'><a href="Range.html#sheet">sheet</a></li><li data-type='method'><a href="Range.html#startCell">startCell</a></li><li data-type='method'><a href="Range.html#style">style</a></li><li data-type='method'><a href="Range.html#style">style</a></li><li data-type='method'><a href="Range.html#style">style</a></li><li data-type='method'><a href="Range.html#style">style</a></li><li data-type='method'><a href="Range.html#style">style</a></li><li data-type='method'><a href="Range.html#style">style</a></li><li data-type='method'><a href="Range.html#style">style</a></li><li data-type='method'><a href="Range.html#tap">tap</a></li><li data-type='method'><a href="Range.html#thru">thru</a></li><li data-type='method'><a href="Range.html#value">value</a></li><li data-type='method'><a href="Range.html#value">value</a></li><li data-type='method'><a href="Range.html#value">value</a></li><li data-type='method'><a href="Range.html#value">value</a></li><li data-type='method'><a href="Range.html#workbook">workbook</a></li></ul></li><li><a href="Reference.html">Reference</a><ul class='methods'><li data-type='method'><a href="Reference.html#retrieve">retrieve</a></li></ul></li><li><a href="ReferenceTable.html">ReferenceTable</a><ul class='methods'><li data-type='method'><a href="ReferenceTable.html#add">add</a></li><li data-type='method'><a href="ReferenceTable.html#getCalculationOrder">getCalculationOrder</a></li><li data-type='method'><a href="ReferenceTable.html#getDirectReferences">getDirectReferences</a></li><li data-type='method'><a href="ReferenceTable.html#remove">remove</a></li></ul></li><li><a href="RichText.html">RichText</a><ul class='methods'><li data-type='method'><a href="RichText.html#add">add</a></li><li data-type='method'><a href="RichText.html#clear">clear</a></li><li data-type='method'><a href="RichText.html#copy">copy</a></li><li data-type='method'><a href="RichText.html#get">get</a></li><li data-type='method'><a href="RichText.html#getInstanceWithCellRef">getInstanceWithCellRef</a></li><li data-type='method'><a href="RichText.html#remove">remove</a></li><li data-type='method'><a href="RichText.html#text">text</a></li></ul></li><li><a href="RichTextFragment.html">RichTextFragment</a><ul class='methods'><li data-type='method'><a href="RichTextFragment.html#style">style</a></li><li data-type='method'><a href="RichTextFragment.html#style">style</a></li><li data-type='method'><a href="RichTextFragment.html#style">style</a></li><li data-type='method'><a href="RichTextFragment.html#style">style</a></li><li data-type='method'><a href="RichTextFragment.html#value">value</a></li><li data-type='method'><a href="RichTextFragment.html#value">value</a></li></ul></li><li><a href="Row.html">Row</a><ul class='methods'><li data-type='method'><a href="Row.html#addPageBreak">addPageBreak</a></li><li data-type='method'><a href="Row.html#address">address</a></li><li data-type='method'><a href="Row.html#cell">cell</a></li><li data-type='method'><a href="Row.html#height">height</a></li><li data-type='method'><a href="Row.html#height">height</a></li><li data-type='method'><a href="Row.html#hidden">hidden</a></li><li data-type='method'><a href="Row.html#hidden">hidden</a></li><li data-type='method'><a href="Row.html#rowNumber">rowNumber</a></li><li data-type='method'><a href="Row.html#sheet">sheet</a></li><li data-type='method'><a href="Row.html#style">style</a></li><li data-type='method'><a href="Row.html#style">style</a></li><li data-type='method'><a href="Row.html#style">style</a></li><li data-type='method'><a href="Row.html#style">style</a></li><li data-type='method'><a href="Row.html#style">style</a></li><li data-type='method'><a href="Row.html#workbook">workbook</a></li></ul></li><li><a href="Sheet.html">Sheet</a><ul class='methods'><li data-type='method'><a href="Sheet.html#active">active</a></li><li data-type='method'><a href="Sheet.html#active">active</a></li><li data-type='method'><a href="Sheet.html#activeCell">activeCell</a></li><li data-type='method'><a href="Sheet.html#activeCell">activeCell</a></li><li data-type='method'><a href="Sheet.html#activeCell">activeCell</a></li><li data-type='method'><a href="Sheet.html#autoFilter">autoFilter</a></li><li data-type='method'><a href="Sheet.html#autoFilter">autoFilter</a></li><li data-type='method'><a href="Sheet.html#cell">cell</a></li><li data-type='method'><a href="Sheet.html#cell">cell</a></li><li data-type='method'><a href="Sheet.html#column">column</a></li><li data-type='method'><a href="Sheet.html#definedName">definedName</a></li><li data-type='method'><a href="Sheet.html#definedName">definedName</a></li><li data-type='method'><a href="Sheet.html#delete">delete</a></li><li data-type='method'><a href="Sheet.html#find">find</a></li><li data-type='method'><a href="Sheet.html#freezePanes">freezePanes</a></li><li data-type='method'><a href="Sheet.html#freezePanes">freezePanes</a></li><li data-type='method'><a href="Sheet.html#getCell">getCell</a></li><li data-type='method'><a href="Sheet.html#gridLinesVisible">gridLinesVisible</a></li><li data-type='method'><a href="Sheet.html#gridLinesVisible">gridLinesVisible</a></li><li data-type='method'><a href="Sheet.html#hidden">hidden</a></li><li data-type='method'><a href="Sheet.html#hidden">hidden</a></li><li data-type='method'><a href="Sheet.html#horizontalPageBreaks">horizontalPageBreaks</a></li><li data-type='method'><a href="Sheet.html#hyperlink">hyperlink</a></li><li data-type='method'><a href="Sheet.html#hyperlink">hyperlink</a></li><li data-type='method'><a href="Sheet.html#hyperlink">hyperlink</a></li><li data-type='method'><a href="Sheet.html#move">move</a></li><li data-type='method'><a href="Sheet.html#name">name</a></li><li data-type='method'><a href="Sheet.html#pageBreaks">pageBreaks</a></li><li data-type='method'><a href="Sheet.html#pageMargins">pageMargins</a></li><li data-type='method'><a href="Sheet.html#pageMargins">pageMargins</a></li><li data-type='method'><a href="Sheet.html#pageMarginsPreset">pageMarginsPreset</a></li><li data-type='method'><a href="Sheet.html#pageMarginsPreset">pageMarginsPreset</a></li><li data-type='method'><a href="Sheet.html#pageMarginsPreset">pageMarginsPreset</a></li><li data-type='method'><a href="Sheet.html#panes">panes</a></li><li data-type='method'><a href="Sheet.html#panes">panes</a></li><li data-type='method'><a href="Sheet.html#printGridLines">printGridLines</a></li><li data-type='method'><a href="Sheet.html#printGridLines">printGridLines</a></li><li data-type='method'><a href="Sheet.html#printOptions">printOptions</a></li><li data-type='method'><a href="Sheet.html#printOptions">printOptions</a></li><li data-type='method'><a href="Sheet.html#range">range</a></li><li data-type='method'><a href="Sheet.html#range">range</a></li><li data-type='method'><a href="Sheet.html#range">range</a></li><li data-type='method'><a href="Sheet.html#resetPanes">resetPanes</a></li><li data-type='method'><a href="Sheet.html#row">row</a></li><li data-type='method'><a href="Sheet.html#splitPanes">splitPanes</a></li><li data-type='method'><a href="Sheet.html#tabColor">tabColor</a></li><li data-type='method'><a href="Sheet.html#tabColor">tabColor</a></li><li data-type='method'><a href="Sheet.html#tabSelected">tabSelected</a></li><li data-type='method'><a href="Sheet.html#tabSelected">tabSelected</a></li><li data-type='method'><a href="Sheet.html#usedRange">usedRange</a></li><li data-type='method'><a href="Sheet.html#verticalPageBreaks">verticalPageBreaks</a></li><li data-type='method'><a href="Sheet.html#workbook">workbook</a></li></ul></li><li><a href="Theme.html">Theme</a><ul class='methods'><li data-type='method'><a href="Theme.html#themeColor">themeColor</a></li></ul></li><li><a href="Workbook.html">Workbook</a><ul class='methods'><li data-type='method'><a href="Workbook.html#activeSheet">activeSheet</a></li><li data-type='method'><a href="Workbook.html#activeSheet">activeSheet</a></li><li data-type='method'><a href="Workbook.html#addSheet">addSheet</a></li><li data-type='method'><a href="Workbook.html#cloneSheet">cloneSheet</a></li><li data-type='method'><a href="Workbook.html#definedName">definedName</a></li><li data-type='method'><a href="Workbook.html#deleteSheet">deleteSheet</a></li><li data-type='method'><a href="Workbook.html#find">find</a></li><li data-type='method'><a href="Workbook.html#getSheetRIdByName">getSheetRIdByName</a></li><li data-type='method'><a href="Workbook.html#moveSheet">moveSheet</a></li><li data-type='method'><a href="Workbook.html#outputAsync">outputAsync</a></li><li data-type='method'><a href="Workbook.html#properties">properties</a></li><li data-type='method'><a href="Workbook.html#property">property</a></li><li data-type='method'><a href="Workbook.html#property">property</a></li><li data-type='method'><a href="Workbook.html#property">property</a></li><li data-type='method'><a href="Workbook.html#property">property</a></li><li data-type='method'><a href="Workbook.html#sheet">sheet</a></li><li data-type='method'><a href="Workbook.html#sheets">sheets</a></li><li data-type='method'><a href="Workbook.html#theme">theme</a></li><li data-type='method'><a href="Workbook.html#toFileAsync">toFileAsync</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="XlsxPopulate.html">XlsxPopulate</a><ul class='methods'><li data-type='method'><a href="XlsxPopulate.html#.dateToNumber">dateToNumber</a></li><li data-type='method'><a href="XlsxPopulate.html#.fromBlankAsync">fromBlankAsync</a></li><li data-type='method'><a href="XlsxPopulate.html#.fromDataAsync">fromDataAsync</a></li><li data-type='method'><a href="XlsxPopulate.html#.fromFileAsync">fromFileAsync</a></li><li data-type='method'><a href="XlsxPopulate.html#.numberToDate">numberToDate</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#_">_</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">workbooks/Workbook.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

const _ = require("lodash");
const fs = require("fs");
const JSZip = require('jszip');

const regexify = require("../regexify");
const blank = require("../blank")();
const xmlq = require("../xml/xmlq");
const Sheet = require("../worksheets/Sheet");
const ContentTypes = require("./ContentTypes");
const AppProperties = require("./AppProperties");
const CoreProperties = require("./CoreProperties");
const Relationships = require("./Relationships");
const SharedStrings = require("./SharedStrings");
const StyleSheet = require("./StyleSheet");
const Theme = require("./Theme");
const Encryptor = require("../Encryptor");
const XmlParser = require("../xml/XmlParser");
const XmlBuilder = require("../xml/XmlBuilder");
const ArgHandler = require("../ArgHandler");
const addressConverter = require("../addressConverter");
const Parser = require('../formula/Parser');
const ReferenceTable = require('../formula/ReferenceTable');
const Reference = require('../formula/Reference');

// Options for adding files to zip. Do not create folders and use a fixed time at epoch.
// The default JSZip behavior uses current time, which causes idential workbooks to be different each time.
const zipFileOpts = {
    date: new Date(0),
    createFolders: false
};

// Initialize the _parser and builder.
const xmlParser = new XmlParser();
const xmlBuilder = new XmlBuilder();

// Initialize the encryptor if present (can be excluded in browser build).
const encryptor = typeof Encryptor === "function" &amp;&amp; new Encryptor();

// Characters not allowed in sheet names.
const badSheetNameChars = ['\\', '/', '*', '[', ']', ':', '?'];

// Excel limits sheet names to 31 chars.
const maxSheetNameLength = 31;

// Order of the nodes as defined by the spec.
const nodeOrder = [
    "fileVersion", "fileSharing", "workbookPr", "workbookProtection", "bookViews", "sheets", "functionGroups",
    "externalReferences", "definedNames", "calcPr", "oleSize", "customWorkbookViews", "pivotCaches", "smartTagPr",
    "smartTagTypes", "webPublishing", "fileRecoveryPr", "webPublishObjects", "extLst"
];

/**
 * A workbook.
 */
class Workbook {
    /**
     * Get formula parser instance.
     * @return {Parser} A Parser instance, which contains dependency parser, formula parser, reference parser.
     */
    get formulaParser() {
        return this._parser;
    }

    /**
     * Create a new blank workbook.
     * @returns {Promise.&lt;Workbook>} The workbook.
     * @ignore
     */
    static fromBlankAsync() {
        return Workbook.fromDataAsync(blank);
    }

    /**
     * Loads a workbook from a data object. (Supports any supported [JSZip data types]{@link https://stuk.github.io/jszip/documentation/api_jszip/load_async.html}.)
     * @param {string|Array.&lt;number>|ArrayBuffer|Uint8Array|Buffer|Blob|Promise.&lt;*>} data - The data to load.
     * @param {{}} [opts] - Options
     * @returns {Promise.&lt;Workbook>} The workbook.
     * @ignore
     */
    static fromDataAsync(data, opts) {
        return new Workbook()._initAsync(data, opts);
    }

    /**
     * Loads a workbook from file.
     * @param {string} path - The path to the workbook.
     * @param {{}} [opts] - Options
     * @returns {Promise.&lt;Workbook>} The workbook.
     * @ignore
     */
    static fromFileAsync(path, opts) {
        if (process.browser) throw new Error("Workbook.fromFileAsync is not supported in the browser");
        return new Promise((resolve, reject) => {
            fs.readFile(path, (err, data) => {
                if (err) return reject(err);
                resolve(data);
            });
        }).then(data => Workbook.fromDataAsync(data, opts));
    }

    /**
     * Get the active sheet in the workbook.
     * @returns {Sheet} The active sheet.
     *//**
     * Set the active sheet in the workbook.
     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to activate. The sheet must not be hidden.
     * @returns {Workbook} The workbook.
     */
    activeSheet() {
        return new ArgHandler('Workbook.activeSheet', arguments)
            .case(() => {
                return this._activeSheet;
            })
            .case('*', sheet => {
                // Get the sheet from name/index if needed.
                if (!(sheet instanceof Sheet)) sheet = this.sheet(sheet);

                // Check if the sheet is hidden.
                if (sheet.hidden()) throw new Error("You may not activate a hidden sheet.");

                // Deselect all sheets except the active one (mirroring ying Excel behavior).
                _.forEach(this._sheets, current => {
                    current.tabSelected(current === sheet);
                });

                this._activeSheet = sheet;

                return this;
            })
            .handle();
    }

    /**
     * Add a new sheet to the workbook.
     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \ / * [ ] : ?
     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
     * @returns {Sheet} The new sheet.
     */
    addSheet(name, indexOrBeforeSheet) {
        return this._addSheet(name, indexOrBeforeSheet);
    }

    /**
     * Gets a defined name scoped to the workbook.
     * @param {string} name - The defined name.
     * @returns {undefined|string|Cell|Range|Row|Column} What the defined name refers to or undefined if not found. Will return the string formula if not a Row, Column, Cell, or Range.
     */
    /**
     * Set a defined name scoped to the workbook.
     * @param {string} name - The defined name.
     * @param {string|Cell|Range|Row|Column} refersTo - What the name refers to.
     * @returns {Workbook} The workbook.
     */
    definedName() {
        return new ArgHandler("Workbook.definedName", arguments)
            .case('string', name => {
                return this.scopedDefinedName(undefined, name);
            })
            .case(['string', '*'], (name, refersTo) => {
                this.scopedDefinedName(undefined, name, refersTo);
                return this;
            })
            .handle();
    }

    /**
     * Delete a sheet from the workbook.
     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.
     * @returns {Workbook} The workbook.
     */
    deleteSheet(sheet) {
        // Get the sheet to move.
        if (!(sheet instanceof Sheet)) {
            sheet = this.sheet(sheet);
            if (!sheet) throw new Error("Invalid move sheet reference.");
        }

        // Make sure we are not deleting the only visible sheet.
        const visibleSheets = _.filter(this._sheets, sheet => !sheet.hidden());
        if (visibleSheets.length === 1 &amp;&amp; visibleSheets[0] === sheet) {
            throw new Error("This sheet may not be deleted as a workbook must contain at least one visible sheet.");
        }

        // Remove the sheet.
        let index = this._sheets.indexOf(sheet);
        this._sheets.splice(index, 1);

        // Set the new active sheet.
        if (sheet === this.activeSheet()) {
            if (index >= this._sheets.length) index--;
            this.activeSheet(index);
        }

        this._reconstructSheetName2Id();
        return this;
    }

    /**
     * Find the given pattern in the workbook and optionally replace it.
     * @param {string|RegExp} pattern - The pattern to look for. Providing a string will result in a case-insensitive substring search. Use a RegExp for more sophisticated searches.
     * @param {string|function} [replacement] - The text to replace or a String.replace callback function. If pattern is a string, all occurrences of the pattern in each cell will be replaced.
     * @returns {boolean} A flag indicating if the pattern was found.
     */
    find(pattern, replacement) {
        pattern = regexify(pattern);

        let matches = [];
        this._sheets.forEach(sheet => {
            matches = matches.concat(sheet.find(pattern, replacement));
        });

        return matches;
    }

    /**
     * Move a sheet to a new position.
     * @param {Sheet|string|number} sheet - The sheet or name of sheet or index of sheet to move.
     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
     * @returns {Workbook} The workbook.
     */
    moveSheet(sheet, indexOrBeforeSheet) {
        // Get the sheet to move.
        if (!(sheet instanceof Sheet)) {
            sheet = this.sheet(sheet);
            if (!sheet) throw new Error("Invalid move sheet reference.");
        }

        // Get the to/from indexes.
        const from = this._sheets.indexOf(sheet);
        let to;
        if (_.isNil(indexOrBeforeSheet)) {
            to = this._sheets.length - 1;
        } else if (_.isInteger(indexOrBeforeSheet)) {
            to = indexOrBeforeSheet;
        } else {
            if (!(indexOrBeforeSheet instanceof Sheet)) {
                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);
                if (!indexOrBeforeSheet) throw new Error("Invalid before sheet reference.");
            }

            to = this._sheets.indexOf(indexOrBeforeSheet);
        }

        // Insert the sheet at the appropriate place.
        this._sheets.splice(to, 0, this._sheets.splice(from, 1)[0]);

        this._reconstructSheetName2Id();

        return this;
    }

    /**
     * Generates the workbook output.
     * @param {string} [type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.
     * @returns {string|Uint8Array|ArrayBuffer|Blob|Buffer} The data.
     */
    /**
     * Generates the workbook output.
     * @param {{}} [opts] Options
     * @param {string} [opts.type] - The type of the data to return: base64, binarystring, uint8array, arraybuffer, blob, nodebuffer. Defaults to 'nodebuffer' in Node.js and 'blob' in browsers.
     * @param {string} [opts.password] - The password to use to encrypt the workbook.
     * @returns {string|Uint8Array|ArrayBuffer|Blob|Buffer} The data.
     */
    outputAsync(opts) {
        opts = opts || {};
        if (typeof opts === 'string') opts = { type: opts };

        this._setSheetRefs();

        let definedNamesNode = xmlq.findChild(this._node, "definedNames");

        this._sheets.forEach((sheet, i) => {
            if (!sheet._autoFilter) return;

            if (!definedNamesNode) {
                definedNamesNode = {
                    name: "definedNames",
                    attributes: {},
                    children: []
                };

                xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);
            }

            xmlq.appendChild(definedNamesNode, {
                name: "definedName",
                attributes: {
                    name: "_xlnm._FilterDatabase",
                    localSheetId: i,
                    hidden: "1"
                },
                children: [sheet._autoFilter.address({ includeSheetName: true, anchored: true })]
            });
        });

        this._sheetsNode.children = [];
        this._sheets.forEach((sheet, i) => {
            const sheetPath = `xl/worksheets/sheet${i + 1}.xml`;
            const sheetRelsPath = `xl/worksheets/_rels/sheet${i + 1}.xml.rels`;
            const sheetXmls = sheet.toXmls();
            const relationship = this._relationships.findById(sheetXmls.id.attributes['r:id']);
            relationship.attributes.Target = `worksheets/sheet${i + 1}.xml`;
            this._sheetsNode.children.push(sheetXmls.id);
            this._zip.file(sheetPath, xmlBuilder.build(sheetXmls.sheet), zipFileOpts);

            const relationshipsXml = xmlBuilder.build(sheetXmls.relationships);
            if (relationshipsXml) {
                this._zip.file(sheetRelsPath, relationshipsXml, zipFileOpts);
            } else {
                this._zip.remove(sheetRelsPath);
            }
        });

        // Set the app security to true if a password is set, false if not.
        // this._appProperties.isSecure(!!opts.password);

        // Convert the various components to XML strings and add them to the zip.
        this._zip.file("[Content_Types].xml", xmlBuilder.build(this._contentTypes), zipFileOpts);
        this._zip.file("docProps/app.xml", xmlBuilder.build(this._appProperties), zipFileOpts);
        this._zip.file("docProps/core.xml", xmlBuilder.build(this._coreProperties), zipFileOpts);
        this._zip.file("xl/_rels/workbook.xml.rels", xmlBuilder.build(this._relationships), zipFileOpts);
        this._zip.file("xl/sharedStrings.xml", xmlBuilder.build(this._sharedStrings), zipFileOpts);
        this._zip.file("xl/styles.xml", xmlBuilder.build(this._styleSheet), zipFileOpts);
        this._zip.file("xl/workbook.xml", xmlBuilder.build(this._node), zipFileOpts);

        // Generate the zip.
        return this._zip.generateAsync({
            type: "nodebuffer",
            compression: "DEFLATE"
        }).then(output => {
            // If a password is set, encrypt the workbook.
            if (opts.password) output = encryptor.encrypt(output, opts.password);

            // Convert and return
            return this._convertBufferToOutput(output, opts.type);
        });
    }

    /**
     * Gets the sheet with the provided name or index (0-based).
     * @param {string|number} sheetNameOrIndex - The sheet name or index.
     * @returns {Sheet|undefined} The sheet or undefined if not found.
     */
    sheet(sheetNameOrIndex) {
        if (_.isInteger(sheetNameOrIndex)) return this._sheets[sheetNameOrIndex];
        return this._sheets[this._sheetName2Id.get(sheetNameOrIndex)];
    }

    /**
     * Get an array of all the sheets in the workbook.
     * @returns {Array.&lt;Sheet>} The sheets.
     */
    sheets() {
        return this._sheets.slice();
    }

    /**
     * Gets an individual property.
     * @param {string} name - The name of the property.
     * @returns {*} The property.
     *//**
     * Gets multiple properties.
     * @param {Array.&lt;string>} names - The names of the properties.
     * @returns {object.&lt;string, *>} Object whose keys are the property names and values are the properties.
     *//**
     * Sets an individual property.
     * @param {string} name - The name of the property.
     * @param {*} value - The value to set.
     * @returns {Workbook} The workbook.
     *//**
     * Sets multiple properties.
     * @param {object.&lt;string, *>} properties - Object whose keys are the property names and values are the values to set.
     * @returns {Workbook} The workbook.
     */
    property() {
        return new ArgHandler("Workbook.property", arguments)
            .case('string', name => {
                // Get single value
                return this._coreProperties.get(name);
            })
            .case('array', names => {
                // Get list of values
                const values = {};
                names.forEach(name => {
                    values[name] = this._coreProperties.get(name);
                });

                return values;
            })
            .case(['string', '*'], (name, value) => {
                // Set a single value for all cells to a single value
                this._coreProperties.set(name, value);
                return this;
            })
            .case('object', nameValues => {
                // Object of key value pairs to set
                for (const name in nameValues) {
                    if (!nameValues.hasOwnProperty(name)) continue;
                    const value = nameValues[name];
                    this._coreProperties.set(name, value);
                }

                return this;
            })
            .handle();
    }

    /**
     * Get access to core properties object
     * @returns {CoreProperties} The core properties.
     */
    properties() {
        return this._coreProperties;
    }

    /**
     * Write the workbook to file. (Not supported in browsers.)
     * @param {string} path - The path of the file to write.
     * @param {{}} [opts] - Options
     * @param {string} [opts.password] - The password to encrypt the workbook.
     * @returns {Promise.&lt;undefined>} A promise.
     */
    toFileAsync(path, opts) {
        if (process.browser) throw new Error("Workbook.toFileAsync is not supported in the browser.");
        return this.outputAsync(opts)
            .then(data => new Promise((resolve, reject) => {
                fs.writeFile(path, data, err => {
                    if (err) return reject(err);
                    resolve();
                });
            }));
    }

    /**
     * Return the number in r:id by sheet name defined in workbook.xml
     * @param {string} sheetName - Sheet name.
     * @return {undefined|number} Sheet Id.
     */
    getSheetRIdByName(sheetName) {
        // &lt;sheets>
        // &lt;sheet r:id="rId1" sheetId="1" name="Sheet1"/>
        // &lt;sheet r:id="rId2" sheetId="2" name="Sheet2"/>
        // &lt;sheet r:id="rId3" sheetId="4" name="Sheet3" state="hidden"/>
        // &lt;/sheets>
        for (let i = 0; i &lt; this._sheetsNode.children.length; i++) {
            const child = this._sheetsNode.children[i];
            if (child.attributes.name === sheetName)
                return Number(child.attributes['r:id'].slice(3));
        }
    }

    /**
     * Gets a scoped defined name.
     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.
     * @param {string} name - The defined name.
     * @returns {undefined|Reference} What the defined name refers to.
     * @ignore
     */
    /**
     * Sets a scoped defined name.
     * @param {Sheet} sheetScope - The sheet the name is scoped to. Use undefined for workbook scope.
     * @param {string} name - The defined name.
     * @param {undefined|Cell|Range|Row|Column} refersTo - What the defined name refers to.
     * @returns {Workbook} The workbook.
     * @ignore
     */
    scopedDefinedName(sheetScope, name, refersTo) {
        if (name === 'Print_Area' || name === 'Print_Titles') {
            name = `_xlnm.${name}`;
        }
        let definedNamesNode = xmlq.findChild(this._node, "definedNames");
        let sheetId;

        // localSheetId are zero-based indexes of sheets as they appear in the
        // workbook (the r:id attribute of the sheet for .xlsx)
        if (sheetScope)
            sheetId = this.getSheetRIdByName(sheetScope.name()) - 1;
        let definedNameNode;
        definedNamesNode.children.forEach(node => {
            if (node.attributes.name === name &amp;&amp; node.attributes.localSheetId === sheetId)
                definedNameNode = node;
        });
        return new ArgHandler('Workbook.scopedDefinedName', arguments)
            .case(['*', 'string'], () => {
                // Get the address from the definedNames node.
                const refersTo = definedNameNode &amp;&amp; definedNameNode.children[0];
                if (!refersTo) return;

                // Try to parse the address.
                const ref = this._parser.parseReference(refersTo);
                if (!ref)
                    throw Error(`Cannot parse reference: ${refersTo}`);
                return new Reference(ref, this);
            })
            .case(['*', 'string', 'nil'], () => {
                if (definedNameNode) xmlq.removeChild(definedNamesNode, definedNameNode);
                if (definedNamesNode &amp;&amp; !definedNamesNode.children.length) xmlq.removeChild(this._node, definedNamesNode);
                return this;
            })
            .case(['*', 'string', '*'], () => {
                if (typeof refersTo !== 'string') {
                    refersTo = refersTo.address({
                        includeSheetName: true,
                        anchored: true
                    });
                }

                if (!definedNamesNode) {
                    definedNamesNode = {
                        name: "definedNames",
                        attributes: {},
                        children: []
                    };

                    xmlq.insertInOrder(this._node, definedNamesNode, nodeOrder);
                }

                if (!definedNameNode) {
                    definedNameNode = {
                        name: "definedName",
                        attributes: { name },
                        children: [refersTo]
                    };

                    if (sheetScope) definedNameNode.localSheet = sheetScope;

                    xmlq.appendChild(definedNamesNode, definedNameNode);
                }

                definedNameNode.children = [refersTo];

                return this;
            })
            .handle();
    }

    /**
     * Get the shared strings table.
     * @returns {SharedStrings} The shared strings table.
     * @ignore
     */
    sharedStrings() {
        return this._sharedStrings;
    }

    /**
     * Get the style sheet.
     * @returns {StyleSheet} The style sheet.
     * @ignore
     */
    styleSheet() {
        return this._styleSheet;
    }

    /**
     * Get the theme of this workbook.
     * @return {Theme} The theme object.
     */
    theme() {
        return this._theme;
    }

    /**
     * Add a new sheet to the workbook.
     *
     * **WARN:** this function has limits:  if you clone a sheet with some images or other things link outside the Sheet object, these things in the cloned sheet will be locked when you open in MS Excel app.
     * @param {Sheet} from - The sheet to be cloned.
     * @param {string} name - The name of the new sheet. Must be unique, less than 31 characters, and may not contain the following characters: \ / * [ ] : ?
     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
     * @returns {Sheet} The new sheet.
     */
    cloneSheet(from, name, indexOrBeforeSheet) {
        if (!from || !(from instanceof Sheet)) throw new Error("Invalid clone from.");

        return this._addSheet(name, indexOrBeforeSheet, () => {
            const cloneXml = node => {
                // If the node has a toXml method, call it.
                if (node &amp;&amp; _.isFunction(node.toXml)) node = node.toXml();

                if (typeof node === 'object') {
                    if (node.name) {
                        const result = {
                            name: node.name,
                            attributes: {},
                            children: []
                        };

                        _.forOwn(node.attributes, (value, name) => {
                            result.attributes[name] = value;
                        });

                        let chld;
                        if (node.children) {
                            node.children.forEach(child => {
                                chld = cloneXml(child);
                                if (child !== null) {
                                    result.children.push(chld);
                                }
                            });
                        }
                        return result;
                    }
                } else if (node !== null) {
                    return node;
                }
                return null;
            };

            // clone SheetNode &amp; relationshipNode from source
            const fromXml = from.toXmls();
            const sheetNode = cloneXml(fromXml.sheet);
            const relationshipNode = cloneXml(fromXml.relationships);
            return { sheetNode, relationshipNode };
        });
    }

    /**
     * Add a new sheet to the workbook.
     * @param {string} name - The name of the sheet. Must be unique, less than 31 characters, and may not contain the following characters: \ / * [ ] : ?
     * @param {number|string|Sheet} [indexOrBeforeSheet] The index to move the sheet to or the sheet (or name of sheet) to move this sheet before. Omit this argument to move to the end of the workbook.
     * @param {callback} [getTemplateNodes] optional callback function for template nodes
     * @returns {Sheet} The new sheet.
     * @private
     */
    _addSheet(name, indexOrBeforeSheet, getTemplateNodes) {
        // Validate the sheet name.
        if (!name || typeof name !== "string") throw new Error("Invalid sheet name.");
        if (_.some(badSheetNameChars, char => name.indexOf(char) >= 0)) throw new Error(`Sheet name may not contain any of the following characters: ${badSheetNameChars.join(" ")}`);
        if (name.length > maxSheetNameLength) throw new Error(`Sheet name may not be greater than ${maxSheetNameLength} characters.`);
        if (this.sheet(name)) throw new Error(`Sheet with name "${name}" already exists.`);

        // Get the destination index of new sheet.
        let index;
        if (_.isNil(indexOrBeforeSheet)) {
            index = this._sheets.length;
        } else if (_.isInteger(indexOrBeforeSheet)) {
            index = indexOrBeforeSheet;
        } else {
            if (!(indexOrBeforeSheet instanceof Sheet)) {
                indexOrBeforeSheet = this.sheet(indexOrBeforeSheet);
                if (!indexOrBeforeSheet) throw new Error("Invalid before sheet reference.");
            }

            index = this._sheets.indexOf(indexOrBeforeSheet);
        }

        // Add a new relationship for the new sheet and create the new sheet ID node.
        const relationship = this._relationships.add("worksheet"); // Leave target blank as it will be filled later.
        const sheetIdNode = {
            name: "sheet",
            attributes: {
                name,
                sheetId: ++this._maxSheetId,
                'r:id': relationship.attributes.Id
            },
            children: []
        };

        // Create the new sheet.
        let sheet;
        if (getTemplateNodes) {
            const { sheetNode, relationshipNode } = getTemplateNodes();
            sheet = new Sheet(this, sheetIdNode, sheetNode, relationshipNode);
        } else {
            sheet = new Sheet(this, sheetIdNode);
        }

        // Insert the sheet at the appropriate index.
        this._sheets.splice(index, 0, sheet);
        this._sheetName2Id.set(name, index);

        return sheet;
    }

    /**
     * Initialize the workbook. (This is separated from the constructor to ease testing.)
     * @param {string|ArrayBuffer|Uint8Array|Buffer|Blob} data - The data to load.
     * @param {{}} [opts] - Options
     * @param {boolean} [opts.base64=false] - No used unless input is a string. True if the input string is base64 encoded, false for binary.
     * @returns {Promise.&lt;Workbook>} The workbook.
     * @private
     */
    _initAsync(data, opts) {
        opts = opts || {};

        this._maxSheetId = 0;
        this._sheets = [];
        this._sheetName2Id = new Map();

        return Promise.resolve()
            .then(() => {
                // Make sure the input is a Buffer
                return this._convertInputToBufferAsync(data, opts.base64)
                    .then(buffer => {
                        data = buffer;
                    });
            })
            .then(() => {
                if (!opts.password) return;
                return encryptor.decryptAsync(data, opts.password)
                    .then(decrypted => {
                        data = decrypted;
                    });
            })
            .then(() => {
                // initiate a formula _parser
                this._refTable = new ReferenceTable();
                this._parser = new Parser(this);
                return this._parser.initAsync();
            })
            .then(() => JSZip.loadAsync(data))
            .then(zip => {
                this._zip = zip;
                return this._parseNodesAsync([
                    "[Content_Types].xml",
                    "docProps/app.xml",
                    "docProps/core.xml",
                    "xl/_rels/workbook.xml.rels",
                    "xl/theme/theme1.xml"
                ]);
            })
            .then(nodes => {
                const contentTypesNode = nodes[0];
                const appPropertiesNode = nodes[1];
                const corePropertiesNode = nodes[2];
                const relationshipsNode = nodes[3];
                const themeNode = nodes[4];

                // Load the various components.
                this._contentTypes = new ContentTypes(contentTypesNode);
                this._appProperties = new AppProperties(appPropertiesNode);
                this._coreProperties = new CoreProperties(corePropertiesNode);
                this._relationships = new Relationships(relationshipsNode);
                this._theme = new Theme(themeNode);

                // Add the shared strings relationship if it doesn't exist.
                if (!this._relationships.findByType("sharedStrings")) {
                    this._relationships.add("sharedStrings", "sharedStrings.xml");
                }

                // Add the shared string content type if it doesn't exist.
                if (!this._contentTypes.findByPartName("/xl/sharedStrings.xml")) {
                    this._contentTypes.add("/xl/sharedStrings.xml", "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml");
                }

                // Kill the calc chain. It's not required and the workbook will corrupt unless we keep it up to date.
                this._zip.remove("xl/calcChain.xml");
            })
            .then(() => {
                return this._parseNodesAsync([
                    "xl/sharedStrings.xml"
                ]);
            })
            .then(nodes => {
                const sharedStringsNode = nodes[0];
                this._sharedStrings = new SharedStrings(sharedStringsNode);
            })
            .then(() => {
                return this._parseNodesAsync([
                    "xl/styles.xml"
                ]);
            })
            .then(nodes => {
                const styleSheetNode = nodes[0];
                this._styleSheet = new StyleSheet(styleSheetNode);
            })
            .then(() => {
                return this._parseNodesAsync([
                    "xl/workbook.xml"
                ]);
            })
            .then(nodes => {
                // workbookNode
                this._node = nodes[0];
                this._sheetsNode = xmlq.findChild(this._node, "sheets");
            })
            .then(() => {
                // Load each sheet.
                return Promise.all(_.map(this._sheetsNode.children, (sheetIdNode, i) => {
                    if (sheetIdNode.attributes.sheetId > this._maxSheetId) this._maxSheetId = sheetIdNode.attributes.sheetId;

                    return this._parseNodesAsync([`xl/worksheets/sheet${i + 1}.xml`, `xl/worksheets/_rels/sheet${i + 1}.xml.rels`])
                        .then(nodes => {
                            const sheetNode = nodes[0];
                            const sheetRelationshipsNode = nodes[1];

                            // Insert at position i as the promises will resolve at different times.
                            this._sheetName2Id.set(`${sheetIdNode.attributes.name}`, i);
                            this._sheets[i] = new Sheet(this, sheetIdNode, sheetNode, sheetRelationshipsNode);
                        });
                }));
            })
            .then(() => {
                // Load sheets
                return Promise.all(this._sheets.map(sheet => {
                    return new Promise(resolve => {
                        setTimeout(() => sheet.initAsync().then(() => resolve()));
                    });
                }));
            })
            .then(() => this._parseSheetRefs())
            .then(() => this);
    }

    /**
     * Parse files out of zip into XML node objects.
     * @param {Array.&lt;string>} names - The file names to parse.
     * @returns {Promise.&lt;Array.&lt;{}>>} An array of the parsed objects.
     * @private
     */
    _parseNodesAsync(names) {
        return Promise.all(_.map(names, name => this._zip.file(name)))
            .then(files => Promise.all(_.map(files, file => file &amp;&amp; file.async("string"))))
            .then(texts => Promise.all(_.map(texts, text => text &amp;&amp; xmlParser.parseAsync(text))));
    }

    /**
     * Parse the sheet references out so we can reorder freely.
     * @returns {undefined}
     * @private
     */
    _parseSheetRefs() {
        // Parse the active sheet.
        const bookViewsNode = xmlq.findChild(this._node, "bookViews");
        const workbookViewNode = bookViewsNode &amp;&amp; xmlq.findChild(bookViewsNode, "workbookView");
        const activeTabId = workbookViewNode &amp;&amp; workbookViewNode.attributes.activeTab || 0;
        this._activeSheet = this._sheets[activeTabId];

        // Set the location sheet on the defined name nodes. The defined name should point to the index of the sheet
        // but reordering sheets messes this up. So store it on the node and we'll update the index on XML build.
        const definedNamesNode = xmlq.findChild(this._node, "definedNames");
        if (definedNamesNode) {
            _.forEach(definedNamesNode.children, definedNameNode => {
                if (definedNameNode.attributes.hasOwnProperty("localSheetId")) {
                    definedNameNode.localSheet = this._sheets[definedNameNode.attributes.localSheetId];
                }
            });
        }
    }

    /**
     * Set the proper sheet references in the XML.
     * @returns {undefined}
     * @private
     */
    _setSheetRefs() {
        // Set the active sheet.
        let bookViewsNode = xmlq.findChild(this._node, "bookViews");
        if (!bookViewsNode) {
            bookViewsNode = { name: 'bookViews', attributes: {}, children: [] };
            xmlq.insertInOrder(this._node, bookViewsNode, nodeOrder);
        }

        let workbookViewNode = xmlq.findChild(bookViewsNode, "workbookView");
        if (!workbookViewNode) {
            workbookViewNode = { name: 'workbookView', attributes: {}, children: [] };
            xmlq.appendChild(bookViewsNode, workbookViewNode);
        }

        workbookViewNode.attributes.activeTab = this._sheets.indexOf(this._activeSheet);

        // Set the defined names local sheet indexes.
        const definedNamesNode = xmlq.findChild(this._node, "definedNames");
        if (definedNamesNode) {
            _.forEach(definedNamesNode.children, definedNameNode => {
                if (definedNameNode.localSheet) {
                    definedNameNode.attributes.localSheetId = this._sheets.indexOf(definedNameNode.localSheet);
                }
            });
        }
    }

    /**
     * Reconstruct SheetName2Id, this can speed up sheet getter.
     * @private
     * @return {undefined}
     */
    _reconstructSheetName2Id() {
        // reconstruct _sheetName2Id
        this._sheetName2Id = new Map();
        this._sheets.forEach((sheet, i) => {
            this._sheetName2Id.set(sheet.name(), i);
        });
    }

    /**
     * Convert buffer to desired output format
     * @param {Buffer} buffer - The buffer
     * @param {string} type - The type to convert to: buffer/nodebuffer, blob, base64, binarystring, uint8array, arraybuffer
     * @returns {Buffer|Blob|string|Uint8Array|ArrayBuffer} The output
     * @private
     */
    _convertBufferToOutput(buffer, type) {
        if (!type) type = process.browser ? "blob" : "nodebuffer";

        if (type === "buffer" || type === "nodebuffer") return buffer;
        if (process.browser &amp;&amp; type === "blob") return new Blob([buffer], { type: Workbook.MIME_TYPE });
        if (type === "base64") return buffer.toString("base64");
        if (type === "binarystring") return buffer.toString("utf8");
        if (type === "uint8array") return new Uint8Array(buffer);
        if (type === "arraybuffer") return new Uint8Array(buffer).buffer;

        throw new Error(`Output type '${type}' not supported.`);
    }

    /**
     * Convert input to buffer
     * @param {Buffer|Blob|string|Uint8Array|ArrayBuffer} input - The input
     * @param {boolean} [base64=false] - Only applies if input is a string. If true, the string is base64 encoded, false for binary
     * @returns {Promise.&lt;Buffer>} The buffer.
     * @private
     */
    _convertInputToBufferAsync(input, base64) {
        return Promise.resolve()
            .then(() => {
                if (Buffer.isBuffer(input)) return input;

                if (process.browser &amp;&amp; input instanceof Blob) {
                    return new Promise(resolve => {
                        const fileReader = new FileReader();
                        fileReader.onload = event => {
                            resolve(Buffer.from(event.target.result));
                        };
                        fileReader.readAsArrayBuffer(input);
                    });
                }

                if (typeof input === "string" &amp;&amp; base64) return Buffer.from(input, "base64");
                if (typeof input === "string" &amp;&amp; !base64) return Buffer.from(input, "utf8");
                if (input instanceof Uint8Array || input instanceof ArrayBuffer) return Buffer.from(input);

                throw new Error(`Input type unknown.`);
            });
    }
}

/**
 * The XLSX mime type.
 * @type {string}
 * @ignore
 */
Workbook.MIME_TYPE = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";

module.exports = Workbook;

/*
xl/workbook.xml

&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
&lt;workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x15" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main">
	&lt;fileVersion appName="xl" lastEdited="7" lowestEdited="7" rupBuild="16925"/>
	&lt;workbookPr defaultThemeVersion="164011"/>
	&lt;mc:AlternateContent xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006">
		&lt;mc:Choice Requires="x15">
			&lt;x15ac:absPath url="\path\to\file" xmlns:x15ac="http://schemas.microsoft.com/office/spreadsheetml/2010/11/ac"/>
		&lt;/mc:Choice>
	&lt;/mc:AlternateContent>
	&lt;bookViews>
		&lt;workbookView xWindow="3720" yWindow="0" windowWidth="27870" windowHeight="12795"/>
	&lt;/bookViews>
	&lt;sheets>
		&lt;sheet name="Sheet1" sheetId="1" r:id="rId1"/>
	&lt;/sheets>
	&lt;calcPr calcId="171027"/>
	&lt;extLst>
		&lt;ext uri="{140A7094-0E35-4892-8432-C4D2E57EDEB5}" xmlns:x15="http://schemas.microsoft.com/office/spreadsheetml/2010/11/main">
			&lt;x15:workbookPr chartTrackingRefBase="1"/>
		&lt;/ext>
	&lt;/extLst>
&lt;/workbook>
// */
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.2</a> on Tue Jul 02 2019 16:55:05 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>



</body>
</html>
